#!/usr/bin/env python
# Line above tells the shell that this file is a Python file and
# to use the Python interpreter to run this file. 
# Should always be included at the top to run from the terminal. 

# The comments below were mostly auto-generated by gr_modtool
# -*- coding: utf-8 -*-
# 
# Copyright 2016 Jamesy Jean-Michel, Lighting Enabled Systems and Applications
# 
# This is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3, or (at your option)
# any later version.
# 
# This software is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this software; see the file COPYING.  If not, write to
# the Free Software Foundation, Inc., 51 Franklin Street,
# Boston, MA 02110-1301, USA.
# 

# The following two lines of code tells Python the modules to include.
# We must always have gr to run GNU Radio applications. NumPy is the
# fundamental package for scientific computing with Python. It contains
# among other things: a powerful N-dimentsional array object (which i'll use),
# useful linear algebra, fourier transform, and random number capabilities.
# PEP8 tells us we should import every module on its own line. 
import numpy
from gnuradio import gr

# Define a class called "trilat_fixed_4in_ff" which is derived from another class, gr.sync_block. 
class trilat_fixed_4in_ff(gr.sync_block):
    """The trilat_fixed_4in_ff block
    This is a sync block with 5 inputs and 4 outputs.
    The main 4 inputs are the squared distances (d^2) between each
    tranmitters' location and the receiver.
    The 5th input (which doesn't make it into the block name) is the
    height (z) used to calculate the squared distance. This input is
    used to adjust the output "z" until the estimated location result
    is within tolerance.
    3 outputs are the calculated X,Y,Z coordinates of the receiver.
    The last output is a flag bit field named "err" (32 bits) to warn
    a user of various situations. For now, only err[0] and err[1] have
    significance. Meaning will be given to more flag bits as this block
    matures.
    err[0] = 1: Not enough signals recived to calculate position
    err[1] = 1: Only 3 SNRs >= treshold, result may be inaccurate

    
    TX1 Coords:
    The cartesian (x,y,z) coordinates of transmitter 1 in that order.
    The number is arbitrary, it only serves to differentiate this
    transmitter from the others coming into this block.
    
    TX2 Coords:
    The cartesian (x,y,z) coordinates of transmitter 2 in that order.
    The number is arbitrary, it only serves to differentiate this
    transmitter from the others coming into this block.
    
    TX3 Coords:
    The cartesian (x,y,z) coordinates of transmitter 3 in that order.
    The number is arbitrary, it only serves to differentiate this
    transmitter from the others coming into this block.
    
    TX4 Coords:
    The cartesian (x,y,z) coordinates of tranmitter 4 in that order.
    The number is arbitrary, it only serves to differentiate this
    transmitter from the others coming into this block.

    
    """
    # The (private) member function "__init__()" is called immediatly to
    # initialize the trilat_fixed_4in_ff class - which already exist.
    # The first argument of every class method, including __init__, is always
    # a reference to the current instance of the class. By convention, this
    # argument is always named self. In the __init__ method, self refers to
    # the newly created object; in other class methods, it refers to the
    # instance whose method was created.
    # (In OOP, a method is a function associated with an object)
    def __init__(self, tx1_coords = numpy.zeros(3, dtype=numpy.float32),\
                       tx2_coords = numpy.zeros(3, dtype=numpy.float32),\
                       tx3_coords = numpy.zeros(3, dtype=numpy.float32),\
                       tx4_coords = numpy.zeros(3, dtype=numpy.float32)):
        # Above, I initialize an N=3-dimensional python array to three 32-bit
        # single precision zeros for (x=0.0, y=0.0, z=0.0) until updated by GRC
        self.tx1_coords = tx1_coords
        self.tx2_coords = tx2_coords
        self.tx3_coords = tx3_coords
        self.tx4_coords = tx4_coords
        # sqrd_d_i_r is the squared distance between reference point r and beacon i
        # In this algorithm, I will use beacon 1 as my reference point
        self.sqrd_d_2_1 = numpy.square(tx2_coords[0]-tx1_coords[0])\
                          + numpy.square(tx2_coords[1]-tx1_coords[1])\
                          + numpy.square(tx2_coords[2]-tx1_coords[2])
        self.sqrd_d_3_1 = numpy.square(tx3_coords[0]-tx1_coords[0])\
                          + numpy.square(tx3_coords[1]-tx1_coords[1])\
                          + numpy.square(tx3_coords[2]-tx1_coords[2])
        self.sqrd_d_4_1 = numpy.square(tx4_coords[0]-tx1_coords[0])\
                          + numpy.square(tx4_coords[1]-tx1_coords[1])\
                          + numpy.square(tx4_coords[2]-tx1_coords[2])
        # I will initialize the coefficient matrix A while still in scope of tx
        # coords - to eliminate need to add "self" later and reduce readability
        self.A = numpy.array([[tx2_coords[0]-tx1_coords[0], tx2_coords[1]-tx1_coords[1], tx2_coords[2]-tx1_coords[2]],\
                              [tx3_coords[0]-tx1_coords[0], tx3_coords[1]-tx1_coords[1], tx3_coords[2]-tx1_coords[2]],\
                              [tx4_coords[0]-tx1_coords[0], tx4_coords[1]-tx1_coords[1], tx4_coords[2]-tx1_coords[2]]])
        # The parent constructor is called (in Python, this needs to be done
        # explicitly. Most things in Python need to be done explicitly ...)
        gr.sync_block.__init__(self,
            name="trilat_fixed_4in_ff",
            # 5 scalar inputs; d^2 to each TX and z_in used in d^2 calculation
            in_sig=[numpy.float32, numpy.float32, numpy.float32, numpy.float32, numpy.float32],
            out_sig=[numpy.float32, numpy.float32, numpy.float32])    ###### UPDATE THIS AS U CHANGE OUTPUT ITEMS !!!!!!


    def work(self, input_items, output_items):
        # The next 4 inputs are the d^2 of each transmitter from the receiver
        sqrd_r1 = input_items[0]
        sqrd_r2 = input_items[1]
        sqrd_r3 = input_items[2]
        sqrd_r4 = input_items[3]
        # z_in used in d^2 calucation; = estimated z element of RX location
        z_in = input_items[4]
        # These are going to be the (x,y,z) outputs
        x = output_items[0]
        y = output_items[1]
        z = output_items[2]
        # This an error flag for this block's algorithm
        # Eventually, setting various bits will have various meanings
        # bit[0] = 1:
##        err = output_items[3]

        # <+signal processing here+>
        # Initially, I test to make sure that no distance is above the height of lights
        #            set the distance threshold to <2.25m (recall that input is squared)
##        d_max = 5.0
##        err_flag = 0              # I am initializing this to no error
##        if (sqrd_r1 > d_max) or (sqrd_r1 > d_max) or (sqrd_r1 > d_max) or (sqrd_r1 > d_max):
##            err_flag = 2          # Error: Only 3 SNRs >= treshold, result may be inaccurate
        # To find the location I will be solving the following linear system
        # of equations in the form A*pos = b where
        # A   is an n-by-3 matrix of coeffcients
        # pos is the transpose of the 3-by-1 matrix [x-x_r, y-y_r, z-z_r]
        # b   is the transpose of the n-by-1 matrix [b_2_1, b_3_1, ..., b_i_1]
        # where b_i_1 = ~(1/2)*[sqrd_r_r - sqrd_r_i + sqrd_d_r_i]
        # Now initialize the matrix B (really a python array), Matrix A is already initialized
        self.b = (1./2.)*numpy.array([sqrd_r1 - sqrd_r2 + self.sqrd_d_2_1,\
                                      sqrd_r1 - sqrd_r3 + self.sqrd_d_3_1,\
                                      sqrd_r1 - sqrd_r4 + self.sqrd_d_4_1])
        # Now I will solve for pos in terms of x_xr, y_yr, z_zr
        x_xr, y_yr, z_zr = numpy.linalg.lstsq(self.A, self.b)[0]
        #upon re-inspection, method below wrong because result = [x-x_r, y-y_r, z-z_r]
        #x[:], y[:], z[:] = numpy.linalg.solve(self.A, self.b)[0]
        # For simplicity and speed, pick just one of the matrix equations for
        # back substitution with z_in to evaluate how much to adjust z (output).
        # Later, to make this more robust, I may pick various combinations of
        # equations for back substitution and combine the results to decide
        # First I need to define a tolerance for position innacuarcies
        absolute_tol = 0.001
        # Now compute the left handside of the b_2_1 equation (could be any b_n_r)
        lhs_2_1 = (self.tx2_coords[0]-self.tx1_coords[0])*((x_xr + self.tx1_coords[0])-self.tx1_coords[0])\
                  + (self.tx2_coords[1]-self.tx1_coords[1])*((y_yr + self.tx1_coords[0])-self.tx1_coords[1])\
                  + (self.tx2_coords[2]-self.tx1_coords[2])*((z_in)-self.tx1_coords[2])
        # Recall the corresponding right handside of the b_2_1 equation is b[0]
        # Now compare to make sure that the values are within tolerance
        # if yes: z_in = z, else: proportionaly adjust z
        ## numpy.allclose(a, b, rtol=1e-05, atol=1e-08, equal_nan=False)
        ## Returns True if two arrays are element-wise equal within a tolerance.
        ## where it essentially does absolute(a - b) <= (atol + rtol * absolute(b))
        ## atol is the absolute tolerance parameter
        ## rtol is The relative tolerance parameter
        if numpy.allclose(lhs_2_1, self.b[0], atol=absolute_tol):
            x[:] = x_xr + self.tx1_coords[0]
            y[:] = y_yr + self.tx1_coords[1]
            z[:] = z_in
        else:
            x[:] = x_xr + self.tx1_coords[0]
            y[:] = y_yr + self.tx1_coords[1]
            z[:] = z_in*(self.b[0]/lhs_2_1)      # this factor will always be >1 or <1
        # output the error flag
##        err[:] = err_flag
        return len(output_items[0])

